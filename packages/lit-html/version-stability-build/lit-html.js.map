{"version":3,"file":"lit-html.js","sources":["../src/lit-html.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// IMPORTANT: these imports must be type-only\nimport type {Directive, DirectiveResult, PartInfo} from './directive.js';\n\nconst DEV_MODE = true;\nconst ENABLE_EXTRA_SECURITY_HOOKS = true;\nconst ENABLE_SHADYDOM_NOPATCH = true;\n\n/**\n * `true` if we're building for google3 with temporary back-compat helpers.\n * This export is not present in prod builds.\n * @internal\n */\nexport const INTERNAL = true;\n\nif (DEV_MODE) {\n  console.warn('lit-html is in dev mode. Not recommended for production!');\n}\n\nconst extraGlobals = window as LitExtraGlobals;\n\nconst wrap =\n  ENABLE_SHADYDOM_NOPATCH &&\n  extraGlobals.ShadyDOM?.inUse &&\n  extraGlobals.ShadyDOM?.noPatch === true\n    ? extraGlobals.ShadyDOM!.wrap\n    : (node: Node) => node;\n\nconst trustedTypes = (globalThis as unknown as Partial<Window>).trustedTypes;\n\n/**\n * Our TrustedTypePolicy for HTML which is declared using the html template\n * tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n */\nconst policy = trustedTypes\n  ? trustedTypes.createPolicy('lit-html', {\n      createHTML: (s) => s,\n    })\n  : undefined;\n\n/**\n * Used to sanitize any value before it is written into the DOM. This can be\n * used to implement a security policy of allowed and disallowed values in\n * order to prevent XSS attacks.\n *\n * One way of using this callback would be to check attributes and properties\n * against a list of high risk fields, and require that values written to such\n * fields be instances of a class which is safe by construction. Closure's Safe\n * HTML Types is one implementation of this technique (\n * https://github.com/google/safe-html-types/blob/master/doc/safehtml-types.md).\n * The TrustedTypes polyfill in API-only mode could also be used as a basis\n * for this technique (https://github.com/WICG/trusted-types).\n *\n * @param node The HTML node (usually either a #text node or an Element) that\n *     is being written to. Note that this is just an exemplar node, the write\n *     may take place against another instance of the same class of node.\n * @param name The name of an attribute or property (for example, 'href').\n * @param type Indicates whether the write that's about to be performed will\n *     be to a property or a node.\n * @return A function that will sanitize this class of writes.\n */\nexport type SanitizerFactory = (\n  node: Node,\n  name: string,\n  type: 'property' | 'attribute'\n) => ValueSanitizer;\n\n/**\n * A function which can sanitize values that will be written to a specific kind\n * of DOM sink.\n *\n * See SanitizerFactory.\n *\n * @param value The value to sanitize. Will be the actual value passed into\n *     the lit-html template literal, so this could be of any type.\n * @return The value to write to the DOM. Usually the same as the input value,\n *     unless sanitization is needed.\n */\nexport type ValueSanitizer = (value: unknown) => unknown;\n\nconst identityFunction: ValueSanitizer = (value: unknown) => value;\nconst noopSanitizer: SanitizerFactory = (\n  _node: Node,\n  _name: string,\n  _type: 'property' | 'attribute'\n) => identityFunction;\n\n/** Sets the global sanitizer factory. */\nconst setSanitizer = (newSanitizer: SanitizerFactory) => {\n  if (!ENABLE_EXTRA_SECURITY_HOOKS) {\n    return;\n  }\n  if (sanitizerFactoryInternal !== noopSanitizer) {\n    throw new Error(\n      `Attempted to overwrite existing lit-html security policy.` +\n        ` setSanitizeDOMValueFactory should be called at most once.`\n    );\n  }\n  sanitizerFactoryInternal = newSanitizer;\n};\n\n/**\n * Only used in internal tests, not a part of the public API.\n */\nconst _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {\n  sanitizerFactoryInternal = noopSanitizer;\n};\n\nconst createSanitizer: SanitizerFactory = (node, name, type) => {\n  return sanitizerFactoryInternal(node, name, type);\n};\n\n// Added to an attribute name to mark the attribute as bound so we can find\n// it easily.\nconst boundAttributeSuffix = '$lit$';\n\n// This marker is used in many syntactic positions in HTML, so it must be\n// a valid element name and attribute name. We don't support dynamic names (yet)\n// but this at least ensures that the parse tree is closer to the template\n// intention.\nconst marker = `lit$${String(Math.random()).slice(9)}$`;\n\n// String used to tell if a comment is a marker comment\nconst markerMatch = '?' + marker;\n\n// Text used to insert a comment marker node. We use processing instruction\n// syntax because it's slightly smaller, but parses as a comment node.\nconst nodeMarker = `<${markerMatch}>`;\n\nconst d = document;\n\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = (v = '') => d.createComment(v);\n\n// https://tc39.github.io/ecma262/#sec-typeof-operator\ntype Primitive = null | undefined | boolean | number | string | symbol | bigint;\nconst isPrimitive = (value: unknown): value is Primitive =>\n  value === null || (typeof value != 'object' && typeof value != 'function');\nconst isArray = Array.isArray;\nconst isIterable = (value: unknown): value is Iterable<unknown> =>\n  isArray(value) ||\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  typeof (value as any)?.[Symbol.iterator] === 'function';\n\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\nconst NAME_CHAR = `[^\\\\s\"'>=/]`;\n\n// These regexes represent the five parsing states that we care about in the\n// Template's HTML scanner. They match the *end* of the state they're named\n// after.\n// Depending on the match, we transition to a new state. If there's no match,\n// we stay in the same state.\n// Note that the regexes are stateful. We utilize lastIndex and sync it\n// across the multiple regexes used. In addition to the five regexes below\n// we also dynamically create a regex to find the matching end tags for raw\n// text elements.\n\n/**\n * End of text is: `<` followed by:\n *   (comment start) or (tag) or (dynamic tag binding)\n */\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\nconst COMMENT_START = 1;\nconst TAG_NAME = 2;\nconst DYNAMIC_TAG_NAME = 3;\n\nconst commentEndRegex = /-->/g;\n/**\n * Comments not started with <!--, like </{, can be ended by a single `>`\n */\nconst comment2EndRegex = />/g;\n\n/**\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\n * position. It either matches a `>`, an attribute-like sequence, or the end\n * of the string after a space (attribute-name position ending).\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\t\\n\\f\\r\" are HTML space characters:\n * https://infra.spec.whatwg.org/#ascii-whitespace\n *\n * So an attribute is:\n *  * The name: any character except a whitespace character, (\"), ('), \">\",\n *    \"=\", or \"/\". Note: this is different from the HTML spec which also excludes control characters.\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst tagEndRegex = new RegExp(\n  `>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`,\n  'g'\n);\nconst ENTIRE_MATCH = 0;\nconst ATTRIBUTE_NAME = 1;\nconst SPACES_AND_EQUALS = 2;\nconst QUOTE_CHAR = 3;\n\nconst singleQuoteAttrEndRegex = /'/g;\nconst doubleQuoteAttrEndRegex = /\"/g;\n/**\n * Matches the raw text elements.\n *\n * Comments are not parsed within raw text elements, so we need to search their\n * text content for marker strings.\n */\nconst rawTextElement = /^(?:script|style|textarea)$/i;\n\n/** TemplateResult types */\nconst HTML_RESULT = 1;\nconst SVG_RESULT = 2;\n\ntype ResultType = typeof HTML_RESULT | typeof SVG_RESULT;\n\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n\n/**\n * The return type of the template tag functions.\n */\nexport type TemplateResult<T extends ResultType = ResultType> = {\n  // This property needs to remain unminified.\n  ['_$litType$']: T;\n  // TODO (justinfagnani): consider shorter names, like `s` and `v`. This is a\n  // semi-public API though. We can't just let Terser rename them for us,\n  // because we need TemplateResults to work between compatible versions of\n  // lit-html.\n  strings: TemplateStringsArray;\n  values: unknown[];\n};\n\nexport type HTMLTemplateResult = TemplateResult<typeof HTML_RESULT>;\n\nexport type SVGTemplateResult = TemplateResult<typeof SVG_RESULT>;\n\nexport interface CompiledTemplateResult {\n  // This is a factory in order to make template initialization lazy\n  // and allow ShadyRenderOptions scope to be passed in.\n  // This property needs to remain unminified.\n  ['_$litType$']: CompiledTemplate;\n  values: unknown[];\n}\n\nexport interface CompiledTemplate extends Omit<Template, 'el'> {\n  // el is overridden to be optional. We initialize it on first render\n  el?: HTMLTemplateElement;\n\n  // The prepared HTML string to create a template element from.\n  h: TrustedHTML;\n}\n\n/**\n * Generates a template literal tag function that returns a TemplateResult with\n * the given result type.\n */\nconst tag =\n  <T extends ResultType>(type: T) =>\n  (strings: TemplateStringsArray, ...values: unknown[]): TemplateResult<T> => {\n    // Warn against templates octal escape sequences\n    // We do this here rather than in render so that the warning is closer to the\n    // template definition.\n    if (DEV_MODE && strings.some((s) => s === undefined)) {\n      console.warn(\n        'Some template strings are undefined.\\n' +\n          'This is probably caused by illegal octal escape sequences.'\n      );\n    }\n    return {\n      // This property needs to remain unminified.\n      ['_$litType$']: type,\n      strings,\n      values,\n    };\n  };\n\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = tag(HTML_RESULT);\n\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = tag(SVG_RESULT);\n\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = Symbol.for('lit-noChange');\n\n/**\n * A sentinel value that signals a ChildPart to fully clear its content.\n */\nexport const nothing = Symbol.for('lit-nothing');\n\n/**\n * The cache of prepared templates, keyed by the tagged TemplateStringsArray\n * and _not_ accounting for the specific template tag used. This means that\n * template tags cannot be dynamic - the must statically be one of html, svg,\n * or attr. This restriction simplifies the cache lookup, which is on the hot\n * path for rendering.\n */\nconst templateCache = new WeakMap<TemplateStringsArray, Template>();\n\nexport interface RenderOptions {\n  /**\n   * An object to use as the `this` value for event listeners. It's often\n   * useful to set this to the host component rendering a template.\n   */\n  host?: object;\n  /**\n   * A DOM node before which to render content in the container.\n   */\n  renderBefore?: ChildNode | null;\n  /**\n   * Node used for cloning the template (`importNode` will be called on this\n   * node). This controls the `ownerDocument` of the rendered DOM, along with\n   * any inherited context. Defaults to the global `document`.\n   */\n  creationScope?: {importNode(node: Node, deep?: boolean): Node};\n}\n\n/**\n * Internally we can export this interface and change the type of\n * render()'s options.\n */\ninterface InternalRenderOptions extends RenderOptions {\n  /**\n   * An internal-only migration flag\n   * @internal\n   */\n  clearContainerForLit2MigrationOnly?: boolean;\n}\n\n/**\n * Renders a value, usually a lit-html TemplateResult, to the container.\n * @param value\n * @param container\n * @param options\n */\nexport const render = (\n  value: unknown,\n  container: HTMLElement | DocumentFragment,\n  options?: RenderOptions\n): ChildPart => {\n  const partOwnerNode = options?.renderBefore ?? container;\n  // This property needs to remain unminified.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let part: ChildPart = (partOwnerNode as any)['_$litPart$'];\n  if (part === undefined) {\n    // Internal modification: don't clear container to match lit-html 2.0\n    if (\n      INTERNAL &&\n      (options as InternalRenderOptions)?.clearContainerForLit2MigrationOnly ===\n        true\n    ) {\n      container.childNodes.forEach((c) => c.remove());\n    }\n    const endNode = options?.renderBefore ?? null;\n    // This property needs to remain unminified.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (partOwnerNode as any)['_$litPart$'] = part = new ChildPart(\n      container.insertBefore(createMarker(), endNode),\n      endNode,\n      undefined,\n      options\n    );\n  }\n  part._$setValue(value);\n  return part;\n};\n\nif (ENABLE_EXTRA_SECURITY_HOOKS) {\n  render.setSanitizer = setSanitizer;\n  render.createSanitizer = createSanitizer;\n  if (DEV_MODE) {\n    render._testOnlyClearSanitizerFactoryDoNotCallOrElse =\n      _testOnlyClearSanitizerFactoryDoNotCallOrElse;\n  }\n}\n\nconst walker = d.createTreeWalker(\n  d,\n  129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */,\n  null,\n  false\n);\n\nlet sanitizerFactoryInternal: SanitizerFactory = noopSanitizer;\n\n//\n// Classes only below here, const variable declarations only above here...\n//\n// Keeping variable declarations and classes together improves minification.\n// Interfaces and type aliases can be interleaved freely.\n//\n\n// Type for classes that have a `_directive` or `_directives[]` field, used by\n// `resolveDirective`\nexport interface DirectiveParent {\n  _$parent?: DirectiveParent;\n  __directive?: Directive;\n  __directives?: Array<Directive | undefined>;\n}\n\n/**\n * Returns an HTML string for the given TemplateStringsArray and result type\n * (HTML or SVG), along with the case-sensitive bound attribute names in\n * template order. The HTML contains comment comment markers denoting the\n * `ChildPart`s and suffixes on bound attributes denoting the `AttributeParts`.\n *\n * @param strings template strings array\n * @param type HTML or SVG\n * @return Array containing `[html, attrNames]` (array returned for terseness,\n *     to avoid object fields since this code is shared with non-minified SSR\n *     code)\n */\nconst getTemplateHtml = (\n  strings: TemplateStringsArray,\n  type: ResultType\n): [TrustedHTML, Array<string | undefined>] => {\n  // Insert makers into the template HTML to represent the position of\n  // bindings. The following code scans the template strings to determine the\n  // syntactic position of the bindings. They can be in text position, where\n  // we insert an HTML comment, attribute value position, where we insert a\n  // sentinel string and re-write the attribute name, or inside a tag where\n  // we insert the sentinel string.\n  const l = strings.length - 1;\n  // Stores the case-sensitive bound attribute names in the order of their\n  // parts. ElementParts are also reflected in this array as undefined\n  // rather than a string, to disambiguate from attribute bindings.\n  const attrNames: Array<string | undefined> = [];\n  let html = type === SVG_RESULT ? '<svg>' : '';\n\n  // When we're inside a raw text tag (not it's text content), the regex\n  // will still be tagRegex so we can find attributes, but will switch to\n  // this regex when the tag ends.\n  let rawTextEndRegex: RegExp | undefined;\n\n  // The current parsing state, represented as a reference to one of the\n  // regexes\n  let regex = textEndRegex;\n\n  for (let i = 0; i < l; i++) {\n    const s = strings[i];\n    // The index of the end of the last attribute name. When this is\n    // positive at end of a string, it means we're in an attribute value\n    // position and need to rewrite the attribute name.\n    // We also use a special value of -2 to indicate that we encountered\n    // the end of a string in attribute name position.\n    let attrNameEndIndex = -1;\n    let attrName: string | undefined;\n    let lastIndex = 0;\n    let match!: RegExpExecArray | null;\n\n    // The conditions in this loop handle the current parse state, and the\n    // assignments to the `regex` variable are the state transitions.\n    while (lastIndex < s.length) {\n      // Make sure we start searching from where we previously left off\n      regex.lastIndex = lastIndex;\n      match = regex.exec(s);\n      if (match === null) {\n        break;\n      }\n      lastIndex = regex.lastIndex;\n      if (regex === textEndRegex) {\n        if (match[COMMENT_START] === '!--') {\n          regex = commentEndRegex;\n        } else if (match[COMMENT_START] !== undefined) {\n          // We started a weird comment, like </{\n          regex = comment2EndRegex;\n        } else if (match[TAG_NAME] !== undefined) {\n          if (rawTextElement.test(match[TAG_NAME])) {\n            // Record if we encounter a raw-text element. We'll switch to\n            // this regex at the end of the tag.\n            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');\n          }\n          regex = tagEndRegex;\n        } else if (match[DYNAMIC_TAG_NAME] !== undefined) {\n          // dynamic tag name\n          regex = tagEndRegex;\n        }\n      } else if (regex === tagEndRegex) {\n        if (match[ENTIRE_MATCH] === '>') {\n          // End of a tag. If we had started a raw-text element, use that\n          // regex\n          regex = rawTextEndRegex ?? textEndRegex;\n          // We may be ending an unquoted attribute value, so make sure we\n          // clear any pending attrNameEndIndex\n          attrNameEndIndex = -1;\n        } else if (match[ATTRIBUTE_NAME] === undefined) {\n          // Attribute name position\n          attrNameEndIndex = -2;\n        } else {\n          attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\n          attrName = match[ATTRIBUTE_NAME];\n          regex =\n            match[QUOTE_CHAR] === undefined\n              ? tagEndRegex\n              : match[QUOTE_CHAR] === '\"'\n              ? doubleQuoteAttrEndRegex\n              : singleQuoteAttrEndRegex;\n        }\n      } else if (\n        regex === doubleQuoteAttrEndRegex ||\n        regex === singleQuoteAttrEndRegex\n      ) {\n        regex = tagEndRegex;\n      } else if (regex === commentEndRegex || regex === comment2EndRegex) {\n        regex = textEndRegex;\n      } else {\n        // Not one of the five state regexes, so it must be the dynamically\n        // created raw text regex and we're at the close of that element.\n        regex = tagEndRegex;\n        rawTextEndRegex = undefined;\n      }\n    }\n\n    if (DEV_MODE) {\n      // If we have a attrNameEndIndex, which indicates that we should\n      // rewrite the attribute name, assert that we're in a valid attribute\n      // position - either in a tag, or a quoted attribute value.\n      console.assert(\n        attrNameEndIndex === -1 ||\n          regex === tagEndRegex ||\n          regex === singleQuoteAttrEndRegex ||\n          regex === doubleQuoteAttrEndRegex,\n        'unexpected parse state B'\n      );\n    }\n\n    // We have four cases:\n    //  1. We're in text position, and not in a raw text element\n    //     (regex === textEndRegex): insert a comment marker.\n    //  2. We have a non-negative attrNameEndIndex which means we need to\n    //     rewrite the attribute name to add a bound attribute suffix.\n    //  3. We're at the non-first binding in a multi-binding attribute, use a\n    //     plain marker.\n    //  4. We're somewhere else inside the tag. If we're in attribute name\n    //     position (attrNameEndIndex === -2), add a sequential suffix to\n    //     generate a unique attribute name.\n\n    // Detect a binding next to self-closing tag end and insert a space to\n    // separate the marker from the tag end:\n    const end =\n      regex === tagEndRegex && strings[i + 1].startsWith('/>') ? ' ' : '';\n    html +=\n      regex === textEndRegex\n        ? s + nodeMarker\n        : attrNameEndIndex >= 0\n        ? (attrNames.push(attrName!),\n          s.slice(0, attrNameEndIndex) +\n            boundAttributeSuffix +\n            s.slice(attrNameEndIndex)) +\n          marker +\n          end\n        : s +\n          marker +\n          (attrNameEndIndex === -2 ? (attrNames.push(undefined), i) : end);\n  }\n\n  const htmlResult: string | TrustedHTML =\n    html + (strings[l] || '<?>') + (type === SVG_RESULT ? '</svg>' : '');\n\n  // Returned as an array for terseness\n  return [\n    policy !== undefined\n      ? policy.createHTML(htmlResult)\n      : (htmlResult as unknown as TrustedHTML),\n    attrNames,\n  ];\n};\n\n/** @internal */\nexport type {Template};\nclass Template {\n  /** @internal */\n  el!: HTMLTemplateElement;\n  /** @internal */\n  parts: Array<TemplatePart> = [];\n\n  constructor(\n    // This property needs to remain unminified.\n    {strings, ['_$litType$']: type}: TemplateResult,\n    options?: RenderOptions\n  ) {\n    let node: Node | null;\n    let nodeIndex = 0;\n    let attrNameIndex = 0;\n    const partCount = strings.length - 1;\n    const parts = this.parts;\n\n    // Create template element\n    const [html, attrNames] = getTemplateHtml(strings, type);\n    this.el = Template.createElement(html, options);\n    walker.currentNode = this.el.content;\n\n    // Reparent SVG nodes into template root\n    if (type === SVG_RESULT) {\n      const content = this.el.content;\n      const svgElement = content.firstChild!;\n      svgElement.remove();\n      content.append(...svgElement.childNodes);\n    }\n\n    // Walk the template to find binding markers and create TemplateParts\n    while ((node = walker.nextNode()) !== null && parts.length < partCount) {\n      if (node.nodeType === 1) {\n        // TODO (justinfagnani): for attempted dynamic tag names, we don't\n        // increment the bindingIndex, and it'll be off by 1 in the element\n        // and off by two after it.\n        if ((node as Element).hasAttributes()) {\n          // We defer removing bound attributes because on IE we might not be\n          // iterating attributes in their template order, and would sometimes\n          // remove an attribute that we still need to create a part for.\n          const attrsToRemove = [];\n          for (const name of (node as Element).getAttributeNames()) {\n            // `name` is the name of the attribute we're iterating over, but not\n            // _neccessarily_ the name of the attribute we will create a part\n            // for. They can be different in browsers that don't iterate on\n            // attributes in source order. In that case the attrNames array\n            // contains the attribute name we'll process next. We only need the\n            // attribute name here to know if we should process a bound attribute\n            // on this element.\n            if (\n              name.endsWith(boundAttributeSuffix) ||\n              name.startsWith(marker)\n            ) {\n              const realName = attrNames[attrNameIndex++];\n              attrsToRemove.push(name);\n              if (realName !== undefined) {\n                // Lowercase for case-sensitive SVG attributes like viewBox\n                const value = (node as Element).getAttribute(\n                  realName.toLowerCase() + boundAttributeSuffix\n                )!;\n                const statics = value.split(marker);\n                const m = /([.?@])?(.*)/.exec(realName)!;\n                parts.push({\n                  type: ATTRIBUTE_PART,\n                  index: nodeIndex,\n                  name: m[2],\n                  strings: statics,\n                  ctor:\n                    m[1] === '.'\n                      ? PropertyPart\n                      : m[1] === '?'\n                      ? BooleanAttributePart\n                      : m[1] === '@'\n                      ? EventPart\n                      : AttributePart,\n                });\n              } else {\n                parts.push({\n                  type: ELEMENT_PART,\n                  index: nodeIndex,\n                });\n              }\n            }\n          }\n          for (const name of attrsToRemove) {\n            (node as Element).removeAttribute(name);\n          }\n        }\n        // TODO (justinfagnani): benchmark the regex against testing for each\n        // of the 3 raw text element names.\n        if (rawTextElement.test((node as Element).tagName)) {\n          // For raw text elements we need to split the text content on\n          // markers, create a Text node for each segment, and create\n          // a TemplatePart for each marker.\n          const strings = (node as Element).textContent!.split(marker);\n          const lastIndex = strings.length - 1;\n          if (lastIndex > 0) {\n            (node as Element).textContent = trustedTypes\n              ? (trustedTypes.emptyScript as unknown as '')\n              : '';\n            // Generate a new text node for each literal section\n            // These nodes are also used as the markers for node parts\n            // We can't use empty text nodes as markers because they're\n            // normalized in some browsers (TODO: check)\n            for (let i = 0; i < lastIndex; i++) {\n              (node as Element).append(strings[i], createMarker());\n              // Walk past the marker node we just added\n              walker.nextNode();\n              parts.push({type: CHILD_PART, index: ++nodeIndex});\n            }\n            // Note because this marker is added after the walker's current\n            // node, it will be walked to in the outer loop (and ignored), so\n            // we don't need to adjust nodeIndex here\n            (node as Element).append(strings[lastIndex], createMarker());\n          }\n        }\n      } else if (node.nodeType === 8) {\n        const data = (node as Comment).data;\n        if (data === markerMatch) {\n          parts.push({type: CHILD_PART, index: nodeIndex});\n        } else {\n          let i = -1;\n          while ((i = (node as Comment).data.indexOf(marker, i + 1)) !== -1) {\n            // Comment node has a binding marker inside, make an inactive part\n            // The binding won't work, but subsequent bindings will\n            // TODO (justinfagnani): consider whether it's even worth it to\n            // make bindings in comments work\n            parts.push({type: COMMENT_PART, index: nodeIndex});\n            // Move to the end of the match\n            i += marker.length - 1;\n          }\n        }\n      }\n      nodeIndex++;\n    }\n  }\n\n  // Overridden via `litHtmlPlatformSupport` to provide platform support.\n  /** @nocollapse */\n  static createElement(html: TrustedHTML, _options?: RenderOptions) {\n    const el = d.createElement('template');\n    el.innerHTML = html as unknown as string;\n    return el;\n  }\n}\n\nexport interface Disconnectable {\n  _$parent?: Disconnectable;\n  _$disconnectableChildren?: Set<Disconnectable>;\n}\n\nfunction resolveDirective(\n  part: ChildPart | AttributePart | ElementPart,\n  value: unknown,\n  parent: DirectiveParent = part,\n  attributeIndex?: number\n): unknown {\n  // Bail early if the value is explicitly noChange. Note, this means any\n  // nested directive is still attached and is not run.\n  if (value === noChange) {\n    return value;\n  }\n  let currentDirective =\n    attributeIndex !== undefined\n      ? (parent as AttributePart).__directives?.[attributeIndex]\n      : (parent as ChildPart | ElementPart | Directive).__directive;\n  const nextDirectiveConstructor = isPrimitive(value)\n    ? undefined\n    : // This property needs to remain unminified.\n      (value as DirectiveResult)['_$litDirective$'];\n  if (currentDirective?.constructor !== nextDirectiveConstructor) {\n    // This property needs to remain unminified.\n    currentDirective?.['_$setDirectiveConnected']?.(false);\n    if (nextDirectiveConstructor === undefined) {\n      currentDirective = undefined;\n    } else {\n      currentDirective = new nextDirectiveConstructor(part as PartInfo);\n      currentDirective._$initialize(part, parent, attributeIndex);\n    }\n    if (attributeIndex !== undefined) {\n      ((parent as AttributePart).__directives ??= [])[attributeIndex] =\n        currentDirective;\n    } else {\n      (parent as ChildPart | Directive).__directive = currentDirective;\n    }\n  }\n  if (currentDirective !== undefined) {\n    value = resolveDirective(\n      part,\n      currentDirective._$resolve(part, (value as DirectiveResult).values),\n      currentDirective,\n      attributeIndex\n    );\n  }\n  return value;\n}\n\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nclass TemplateInstance {\n  /** @internal */\n  _$template: Template;\n  /** @internal */\n  _parts: Array<Part | undefined> = [];\n\n  /** @internal */\n  _$parent: Disconnectable;\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  constructor(template: Template, parent: ChildPart) {\n    this._$template = template;\n    this._$parent = parent;\n  }\n\n  // This method is separate from the constructor because we need to return a\n  // DocumentFragment and we don't want to hold onto it with an instance field.\n  _clone(options: RenderOptions | undefined) {\n    const {\n      el: {content},\n      parts: parts,\n    } = this._$template;\n    const fragment = (options?.creationScope ?? d).importNode(content, true);\n    walker.currentNode = fragment;\n\n    let node = walker.nextNode()!;\n    let nodeIndex = 0;\n    let partIndex = 0;\n    let templatePart = parts[0];\n\n    while (templatePart !== undefined) {\n      if (nodeIndex === templatePart.index) {\n        let part: Part | undefined;\n        if (templatePart.type === CHILD_PART) {\n          part = new ChildPart(\n            node as HTMLElement,\n            node.nextSibling,\n            this,\n            options\n          );\n        } else if (templatePart.type === ATTRIBUTE_PART) {\n          part = new templatePart.ctor(\n            node as HTMLElement,\n            templatePart.name,\n            templatePart.strings,\n            this,\n            options\n          );\n        } else if (templatePart.type === ELEMENT_PART) {\n          part = new ElementPart(node as HTMLElement, this, options);\n        }\n        this._parts.push(part);\n        templatePart = parts[++partIndex];\n      }\n      if (nodeIndex !== templatePart?.index) {\n        node = walker.nextNode()!;\n        nodeIndex++;\n      }\n    }\n    return fragment;\n  }\n\n  _update(values: Array<unknown>) {\n    let i = 0;\n    for (const part of this._parts) {\n      if (part !== undefined) {\n        if ((part as AttributePart).strings !== undefined) {\n          (part as AttributePart)._$setValue(values, part as AttributePart, i);\n          // The number of values the part consumes is part.strings.length - 1\n          // since values are in between template spans. We increment i by 1\n          // later in the loop, so increment it by part.strings.length - 2 here\n          i += (part as AttributePart).strings!.length - 2;\n        } else {\n          part._$setValue(values[i]);\n        }\n      }\n      i++;\n    }\n  }\n}\n\n/*\n * Parts\n */\ntype AttributeTemplatePart = {\n  readonly type: typeof ATTRIBUTE_PART;\n  readonly index: number;\n  readonly name: string;\n  /** @internal */\n  readonly ctor: typeof AttributePart;\n  /** @internal */\n  readonly strings: ReadonlyArray<string>;\n};\ntype NodeTemplatePart = {\n  readonly type: typeof CHILD_PART;\n  readonly index: number;\n};\ntype ElementTemplatePart = {\n  readonly type: typeof ELEMENT_PART;\n  readonly index: number;\n};\ntype CommentTemplatePart = {\n  readonly type: typeof COMMENT_PART;\n  readonly index: number;\n};\n\n/**\n * A TemplatePart represents a dynamic part in a template, before the template\n * is instantiated. When a template is instantiated Parts are created from\n * TemplateParts.\n */\ntype TemplatePart =\n  | NodeTemplatePart\n  | AttributeTemplatePart\n  | ElementTemplatePart\n  | CommentTemplatePart;\n\nexport type Part =\n  | ChildPart\n  | AttributePart\n  | PropertyPart\n  | BooleanAttributePart\n  | ElementPart\n  | EventPart;\n\nexport type {ChildPart};\nclass ChildPart {\n  readonly type = CHILD_PART;\n  readonly options: RenderOptions | undefined;\n  _$committedValue: unknown;\n  /** @internal */\n  __directive?: Directive;\n  /** @internal */\n  _$startNode: ChildNode;\n  /** @internal */\n  _$endNode: ChildNode | null;\n  private _textSanitizer: ValueSanitizer | undefined;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n\n  // The following fields will be patched onto ChildParts when required by\n  // AsyncDirective\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n  /** @internal */\n  _$setChildPartConnected?(\n    isConnected: boolean,\n    removeFromParent?: boolean,\n    from?: number\n  ): void;\n  /** @internal */\n  _$reparentDisconnectables?(parent: Disconnectable): void;\n\n  constructor(\n    startNode: ChildNode,\n    endNode: ChildNode | null,\n    parent: TemplateInstance | ChildPart | undefined,\n    options: RenderOptions | undefined\n  ) {\n    this._$startNode = startNode;\n    this._$endNode = endNode;\n    this._$parent = parent;\n    this.options = options;\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      // Explicitly initialize for consistent class shape.\n      this._textSanitizer = undefined;\n    }\n  }\n\n  /**\n   * Sets the connection state for any `AsyncDirectives` contained\n   * within this part and runs their `disconnected` or `reconnected`, according\n   * to the `isConnected` argument.\n   */\n  setConnected(isConnected: boolean) {\n    this._$setChildPartConnected?.(isConnected);\n  }\n\n  /**\n   * The parent node into which the part renders its content.\n   *\n   * A ChildPart's content consists of a range of adjacent child nodes of\n   * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and\n   * `.endNode`).\n   *\n   * - If both `.startNode` and `.endNode` are non-null, then the part's content\n   * consists of all siblings between `.startNode` and `.endNode`, exclusively.\n   *\n   * - If `.startNode` is non-null but `.endNode` is null, then the part's\n   * content consists of all siblings following `.startNode`, up to and\n   * including the last child of `.parentNode`. If `.endNode` is non-null, then\n   * `.startNode` will always be non-null.\n   *\n   * - If both `.endNode` and `.startNode` are null, then the part's content\n   * consists of all child nodes of `.parentNode`.\n   */\n  get parentNode(): Node {\n    return wrap(this._$startNode).parentNode!;\n  }\n\n  /**\n   * The part's leading marker node, if any. See `.parentNode` for more\n   * information.\n   */\n  get startNode(): Node | null {\n    return this._$startNode;\n  }\n\n  /**\n   * The part's trailing marker node, if any. See `.parentNode` for more\n   * information.\n   */\n  get endNode(): Node | null {\n    return this._$endNode;\n  }\n\n  _$setValue(value: unknown, directiveParent: DirectiveParent = this): void {\n    value = resolveDirective(this, value, directiveParent);\n    if (isPrimitive(value)) {\n      // Non-rendering child values. It's important that these do not render\n      // empty text nodes to avoid issues with preventing default <slot>\n      // fallback content.\n      if (value === nothing || value == null || value === '') {\n        if (this._$committedValue !== nothing) {\n          this._$clear();\n        }\n        this._$committedValue = nothing;\n      } else if (value !== this._$committedValue && value !== noChange) {\n        this._commitText(value);\n      }\n      // This property needs to remain unminified.\n    } else if ((value as TemplateResult)['_$litType$'] !== undefined) {\n      this._commitTemplateResult(value as TemplateResult);\n    } else if ((value as Node).nodeType !== undefined) {\n      this._commitNode(value as Node);\n    } else if (isIterable(value)) {\n      this._commitIterable(value);\n    } else {\n      // Fallback, will render the string representation\n      this._commitText(value);\n    }\n  }\n\n  private _insert<T extends Node>(node: T, ref = this._$endNode) {\n    return wrap(wrap(this._$startNode).parentNode!).insertBefore(node, ref);\n  }\n\n  private _commitNode(value: Node): void {\n    if (this._$committedValue !== value) {\n      this._$clear();\n      if (\n        ENABLE_EXTRA_SECURITY_HOOKS &&\n        sanitizerFactoryInternal !== noopSanitizer\n      ) {\n        const parentNodeName = this._$startNode.parentNode?.nodeName;\n        if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {\n          this._insert(\n            new Text(\n              '/* lit-html will not write ' +\n                'TemplateResults to scripts and styles */'\n            )\n          );\n          return;\n        }\n      }\n      this._$committedValue = this._insert(value);\n    }\n  }\n\n  private _commitText(value: unknown): void {\n    const node = wrap(this._$startNode).nextSibling;\n    // TODO(justinfagnani): Can we just check if this._$committedValue is primitive?\n    if (\n      node !== null &&\n      node.nodeType === 3 /* Node.TEXT_NODE */ &&\n      (this._$endNode === null\n        ? wrap(node).nextSibling === null\n        : node === wrap(this._$endNode).previousSibling)\n    ) {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(node, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n      }\n      // If we only have a single text node between the markers, we can just\n      // set its value, rather than replacing it.\n      (node as Text).data = value as string;\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        const textNode = document.createTextNode('');\n        this._commitNode(textNode);\n        // When setting text content, for security purposes it matters a lot\n        // what the parent is. For example, <style> and <script> need to be\n        // handled with care, while <span> does not. So first we need to put a\n        // text node into the document, then we can sanitize its contentx.\n        if (this._textSanitizer === undefined) {\n          this._textSanitizer = createSanitizer(textNode, 'data', 'property');\n        }\n        value = this._textSanitizer(value);\n        textNode.data = value as string;\n      } else {\n        this._commitNode(d.createTextNode(value as string));\n      }\n    }\n    this._$committedValue = value;\n  }\n\n  private _commitTemplateResult(\n    result: TemplateResult | CompiledTemplateResult\n  ): void {\n    // This property needs to remain unminified.\n    const {values, ['_$litType$']: type} = result;\n    // If $litType$ is a number, result is a plain TemplateResult and we get\n    // the template from the template cache. If not, result is a\n    // CompiledTemplateResult and _$litType$ is a CompiledTemplate and we need\n    // to create the <template> element the first time we see it.\n    const template: Template | CompiledTemplate =\n      typeof type === 'number'\n        ? this._$getTemplate(result as TemplateResult)\n        : (type.el === undefined &&\n            (type.el = Template.createElement(type.h, this.options)),\n          type);\n\n    if ((this._$committedValue as TemplateInstance)?._$template === template) {\n      (this._$committedValue as TemplateInstance)._update(values);\n    } else {\n      const instance = new TemplateInstance(template as Template, this);\n      const fragment = instance._clone(this.options);\n      instance._update(values);\n      this._commitNode(fragment);\n      this._$committedValue = instance;\n    }\n  }\n\n  // Overridden via `litHtmlPlatformSupport` to provide platform support.\n  /** @internal */\n  _$getTemplate(result: TemplateResult) {\n    let template = templateCache.get(result.strings);\n    if (template === undefined) {\n      templateCache.set(result.strings, (template = new Template(result)));\n    }\n    return template;\n  }\n\n  private _commitIterable(value: Iterable<unknown>): void {\n    // For an Iterable, we create a new InstancePart per item, then set its\n    // value to the item. This is a little bit of overhead for every item in\n    // an Iterable, but it lets us recurse easily and efficiently update Arrays\n    // of TemplateResults that will be commonly returned from expressions like:\n    // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n\n    // If value is an array, then the previous render was of an\n    // iterable and value will contain the ChildParts from the previous\n    // render. If value is not an array, clear this part and make a new\n    // array for ChildParts.\n    if (!isArray(this._$committedValue)) {\n      this._$committedValue = [];\n      this._$clear();\n    }\n\n    // Lets us keep track of how many items we stamped so we can clear leftover\n    // items from a previous render\n    const itemParts = this._$committedValue as ChildPart[];\n    let partIndex = 0;\n    let itemPart: ChildPart | undefined;\n\n    for (const item of value) {\n      if (partIndex === itemParts.length) {\n        // If no existing part, create a new one\n        // TODO (justinfagnani): test perf impact of always creating two parts\n        // instead of sharing parts between nodes\n        // https://github.com/lit/lit/issues/1266\n        itemParts.push(\n          (itemPart = new ChildPart(\n            this._insert(createMarker()),\n            this._insert(createMarker()),\n            this,\n            this.options\n          ))\n        );\n      } else {\n        // Reuse an existing part\n        itemPart = itemParts[partIndex];\n      }\n      itemPart._$setValue(item);\n      partIndex++;\n    }\n\n    if (partIndex < itemParts.length) {\n      // itemParts always have end nodes\n      this._$clear(\n        itemPart && wrap(itemPart._$endNode!).nextSibling,\n        partIndex\n      );\n      // Truncate the parts array so _value reflects the current state\n      itemParts.length = partIndex;\n    }\n  }\n\n  /**\n   * Removes the nodes contained within this Part from the DOM.\n   *\n   * @param start Start node to clear from, for clearing a subset of the part's\n   *     DOM (used when truncating iterables)\n   * @param from  When `start` is specified, the index within the iterable from\n   *     which ChildParts are being removed, used for disconnecting directives in\n   *     those Parts.\n   *\n   * @internal\n   */\n  _$clear(\n    start: ChildNode | null = wrap(this._$startNode).nextSibling,\n    from?: number\n  ) {\n    this._$setChildPartConnected?.(false, true, from);\n    while (start && start !== this._$endNode) {\n      const n = wrap(start!).nextSibling;\n      (wrap(start!) as Element).remove();\n      start = n;\n    }\n  }\n}\n\nexport type {AttributePart};\nclass AttributePart {\n  readonly type = ATTRIBUTE_PART as\n    | typeof ATTRIBUTE_PART\n    | typeof PROPERTY_PART\n    | typeof BOOLEAN_ATTRIBUTE_PART\n    | typeof EVENT_PART;\n  readonly element: HTMLElement;\n  readonly name: string;\n  readonly options: RenderOptions | undefined;\n\n  /**\n   * If this attribute part represents an interpolation, this contains the\n   * static strings of the interpolation. For single-value, complete bindings,\n   * this is undefined.\n   */\n  readonly strings?: ReadonlyArray<string>;\n  /** @internal */\n  _$committedValue: unknown | Array<unknown> = nothing;\n  /** @internal */\n  __directives?: Array<Directive | undefined>;\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  protected _sanitizer: ValueSanitizer | undefined;\n\n  get tagName() {\n    return this.element.tagName;\n  }\n\n  constructor(\n    element: HTMLElement,\n    name: string,\n    strings: ReadonlyArray<string>,\n    parent: Disconnectable | undefined,\n    options: RenderOptions | undefined\n  ) {\n    this.element = element;\n    this.name = name;\n    this._$parent = parent;\n    this.options = options;\n    if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n      this._$committedValue = new Array(strings.length - 1).fill(nothing);\n      this.strings = strings;\n    } else {\n      this._$committedValue = nothing;\n    }\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      this._sanitizer = undefined;\n    }\n  }\n\n  /**\n   * Sets the value of this part by resolving the value from possibly multiple\n   * values and static strings and committing it to the DOM.\n   * If this part is single-valued, `this._strings` will be undefined, and the\n   * method will be called with a single value argument. If this part is\n   * multi-value, `this._strings` will be defined, and the method is called\n   * with the value array of the part's owning TemplateInstance, and an offset\n   * into the value array from which the values should be read.\n   * This method is overloaded this way to eliminate short-lived array slices\n   * of the template instance values, and allow a fast-path for single-valued\n   * parts.\n   *\n   * @param value The part value, or an array of values for multi-valued parts\n   * @param valueIndex the index to start reading values from. `undefined` for\n   *   single-valued parts\n   * @param noCommit causes the part to not commit its value to the DOM. Used\n   *   in hydration to prime attribute parts with their first-rendered value,\n   *   but not set the attribute, and in SSR to no-op the DOM operation and\n   *   capture the value for serialization.\n   *\n   * @internal\n   */\n  _$setValue(\n    value: unknown | Array<unknown>,\n    directiveParent: DirectiveParent = this,\n    valueIndex?: number,\n    noCommit?: boolean\n  ) {\n    const strings = this.strings;\n\n    // Whether any of the values has changed, for dirty-checking\n    let change = false;\n\n    if (strings === undefined) {\n      // Single-value binding case\n      value = resolveDirective(this, value, directiveParent, 0);\n      change =\n        !isPrimitive(value) ||\n        (value !== this._$committedValue && value !== noChange);\n      if (change) {\n        this._$committedValue = value;\n      }\n    } else {\n      // Interpolation case\n      const values = value as Array<unknown>;\n      value = strings[0];\n\n      let i, v;\n      for (i = 0; i < strings.length - 1; i++) {\n        v = resolveDirective(this, values[valueIndex! + i], directiveParent, i);\n\n        if (v === noChange) {\n          // If the user-provided value is `noChange`, use the previous value\n          v = (this._$committedValue as Array<unknown>)[i];\n        }\n        change ||=\n          !isPrimitive(v) || v !== (this._$committedValue as Array<unknown>)[i];\n        if (v === nothing) {\n          value = nothing;\n        } else if (value !== nothing) {\n          value += (v ?? '') + strings[i + 1];\n        }\n        // We always record each value, even if one is `nothing`, for future\n        // change detection.\n        (this._$committedValue as Array<unknown>)[i] = v;\n      }\n    }\n    if (change && !noCommit) {\n      this._commitValue(value);\n    }\n  }\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (value === nothing) {\n      (wrap(this.element) as Element).removeAttribute(this.name);\n    } else {\n      if (ENABLE_EXTRA_SECURITY_HOOKS) {\n        if (this._sanitizer === undefined) {\n          this._sanitizer = sanitizerFactoryInternal(\n            this.element,\n            this.name,\n            'attribute'\n          );\n        }\n        value = this._sanitizer(value ?? '');\n      }\n      (wrap(this.element) as Element).setAttribute(\n        this.name,\n        (value ?? '') as string\n      );\n    }\n  }\n}\n\nexport type {PropertyPart};\nclass PropertyPart extends AttributePart {\n  readonly type = PROPERTY_PART;\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (ENABLE_EXTRA_SECURITY_HOOKS) {\n      if (this._sanitizer === undefined) {\n        this._sanitizer = sanitizerFactoryInternal(\n          this.element,\n          this.name,\n          'property'\n        );\n      }\n      value = this._sanitizer(value);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (this.element as any)[this.name] = value === nothing ? undefined : value;\n  }\n}\n\nexport type {BooleanAttributePart};\nclass BooleanAttributePart extends AttributePart {\n  readonly type = BOOLEAN_ATTRIBUTE_PART;\n\n  /** @internal */\n  _commitValue(value: unknown) {\n    if (value && value !== nothing) {\n      (wrap(this.element) as Element).setAttribute(this.name, '');\n    } else {\n      (wrap(this.element) as Element).removeAttribute(this.name);\n    }\n  }\n}\n\ntype EventListenerWithOptions = EventListenerOrEventListenerObject &\n  Partial<AddEventListenerOptions>;\n\n/**\n * An AttributePart that manages an event listener via add/removeEventListener.\n *\n * This part works by adding itself as the event listener on an element, then\n * delegating to the value passed to it. This reduces the number of calls to\n * add/removeEventListener if the listener changes frequently, such as when an\n * inline function is used as a listener.\n *\n * Because event options are passed when adding listeners, we must take case\n * to add and remove the part as a listener when the event options change.\n */\nexport type {EventPart};\nclass EventPart extends AttributePart {\n  readonly type = EVENT_PART;\n\n  // EventPart does not use the base _$setValue/_resolveValue implementation\n  // since the dirty checking is more complex\n  /** @internal */\n  _$setValue(newListener: unknown, directiveParent: DirectiveParent = this) {\n    newListener =\n      resolveDirective(this, newListener, directiveParent, 0) ?? nothing;\n    if (newListener === noChange) {\n      return;\n    }\n    const oldListener = this._$committedValue;\n\n    // If the new value is nothing or any options change we have to remove the\n    // part as a listener.\n    const shouldRemoveListener =\n      (newListener === nothing && oldListener !== nothing) ||\n      (newListener as EventListenerWithOptions).capture !==\n        (oldListener as EventListenerWithOptions).capture ||\n      (newListener as EventListenerWithOptions).once !==\n        (oldListener as EventListenerWithOptions).once ||\n      (newListener as EventListenerWithOptions).passive !==\n        (oldListener as EventListenerWithOptions).passive;\n\n    // If the new value is not nothing and we removed the listener, we have\n    // to add the part as a listener.\n    const shouldAddListener =\n      newListener !== nothing &&\n      (oldListener === nothing || shouldRemoveListener);\n\n    if (shouldRemoveListener) {\n      this.element.removeEventListener(\n        this.name,\n        this,\n        oldListener as EventListenerWithOptions\n      );\n    }\n    if (shouldAddListener) {\n      // Beware: IE11 and Chrome 41 don't like using the listener as the\n      // options object. Figure out how to deal w/ this in IE11 - maybe\n      // patch addEventListener?\n      this.element.addEventListener(\n        this.name,\n        this,\n        newListener as EventListenerWithOptions\n      );\n    }\n    this._$committedValue = newListener;\n  }\n\n  handleEvent(event: Event) {\n    if (typeof this._$committedValue === 'function') {\n      // TODO (justinfagnani): do we need to default to this.element?\n      // It'll always be the same as `e.currentTarget`.\n      this._$committedValue.call(this.options?.host ?? this.element, event);\n    } else {\n      (this._$committedValue as EventListenerObject).handleEvent(event);\n    }\n  }\n}\n\nexport type {ElementPart};\nclass ElementPart {\n  readonly type = ELEMENT_PART;\n\n  /** @internal */\n  __directive?: Directive;\n\n  // This is to ensure that every Part has a _$committedValue\n  _$committedValue: undefined;\n\n  /** @internal */\n  _$parent: Disconnectable | undefined;\n\n  /** @internal */\n  _$disconnectableChildren?: Set<Disconnectable> = undefined;\n\n  options: RenderOptions | undefined;\n\n  constructor(\n    public element: Element,\n    parent: Disconnectable,\n    options: RenderOptions | undefined\n  ) {\n    this._$parent = parent;\n    this.options = options;\n  }\n\n  _$setValue(value: unknown): void {\n    resolveDirective(this, value);\n  }\n}\n\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _$LH object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * This has a unique name, to disambiguate it from private exports in\n * lit-element, which re-exports all of lit-html.\n *\n * @private\n */\nexport const _$LH = {\n  // Used in lit-ssr\n  _boundAttributeSuffix: boundAttributeSuffix,\n  _marker: marker,\n  _markerMatch: markerMatch,\n  _HTML_RESULT: HTML_RESULT,\n  _getTemplateHtml: getTemplateHtml,\n  // Used in hydrate\n  _TemplateInstance: TemplateInstance,\n  _isIterable: isIterable,\n  _resolveDirective: resolveDirective,\n  // Used in tests and private-ssr-support\n  _ChildPart: ChildPart,\n  _AttributePart: AttributePart,\n  _BooleanAttributePart: BooleanAttributePart,\n  _EventPart: EventPart,\n  _PropertyPart: PropertyPart,\n  _ElementPart: ElementPart,\n};\n\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(globalThis as any)['litHtmlPlatformSupport']?.(Template, ChildPart);\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((globalThis as any)['litHtmlVersions'] ??= []).push('2.0.0-rc.3');\n"],"names":["trustedTypes","globalThis","policy","createPolicy","createHTML","s","undefined","marker","Math","random","String","slice","markerMatch","nodeMarker","d","document","createMarker","v","createComment","isPrimitive","value","isArray","Array","isIterable","Symbol","iterator","textEndRegex","commentEndRegex","comment2EndRegex","tagEndRegex","singleQuoteAttrEndRegex","doubleQuoteAttrEndRegex","rawTextElement","tag","type","strings","values","_$litType$","html","svg","noChange","for","nothing","templateCache","WeakMap","render","container","options","partOwnerNode","renderBefore","part","endNode","ChildPart","insertBefore","_$setValue","walker","createTreeWalker","getTemplateHtml","l","length","attrNames","rawTextEndRegex","regex","i","attrName","match","attrNameEndIndex","lastIndex","exec","test","RegExp","end","startsWith","push","htmlResult","Template","[object Object]","node","this","nodeIndex","attrNameIndex","partCount","parts","el","createElement","currentNode","content","svgElement","firstChild","remove","append","childNodes","nextNode","nodeType","hasAttributes","attrsToRemove","name","getAttributeNames","endsWith","realName","statics","getAttribute","toLowerCase","split","m","index","ctor","PropertyPart","BooleanAttributePart","EventPart","AttributePart","removeAttribute","tagName","textContent","emptyScript","data","indexOf","_options","innerHTML","resolveDirective","parent","attributeIndex","currentDirective","__directives","__directive","nextDirectiveConstructor","constructor","_$initialize","_$resolve","TemplateInstance","template","_$template","_$parent","fragment","creationScope","importNode","partIndex","templatePart","nextSibling","ElementPart","_parts","startNode","_$startNode","_$endNode","isConnected","_$setChildPartConnected","parentNode","directiveParent","_$committedValue","_$clear","_commitText","_commitTemplateResult","_commitNode","_commitIterable","ref","_insert","previousSibling","createTextNode","result","_$getTemplate","h","_update","instance","_clone","get","set","itemParts","itemPart","item","start","from","n","element","fill","valueIndex","noCommit","change","_commitValue","setAttribute","newListener","oldListener","shouldRemoveListener","capture","once","passive","shouldAddListener","removeEventListener","addEventListener","event","call","host","handleEvent","_$LH","VERSION_TEST_S","VERSION_TEST_P","VERSION_TEST_k","VERSION_TEST_V","VERSION_TEST_C","VERSION_TEST_R","VERSION_TEST_I","VERSION_TEST_D","VERSION_TEST_N","VERSION_TEST_L","VERSION_TEST_j","VERSION_TEST_H","VERSION_TEST_O","VERSION_TEST_W"],"mappings":"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"}